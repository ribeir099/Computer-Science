package main.java.database;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;

/*
 * Responsible for managing all operations and
 * manipulations that may occur in the "database".
 */
public class Database {
  /*
   * Provides the reading and writing operations
   * in the file specified.
   */
  private RandomAccessFile raf; // Tirei a declaração do final para fazer a sobreposição do arquivo ordenado;
  private final int totalRecords = 17560;
  private int ways = 2;
  private int readRecords = 1000;

  public Database(File file) throws IOException {
    this.raf = new RandomAccessFile(file, "rw");
    this.initialize();
  }

  private void initialize() throws IOException {
    try {
      Record[] records = CSVParser.parse();

      /*
       * Storing the highest "id" value before the records is clever
       * cause this attribute should not be user-defined and new
       * values are easily generated by incrementation.
       */
      int lastId = records[records.length - 1].getId();
      raf.writeInt(lastId);

      for (Record record : records)
        record.serialize(raf);

    } catch (IOException e) {
      throw new IOException(
          "Error while initializing the database", e);
    }
  }

  /*
   * Returns the entity with the corresponding "id" value
   * and null if it isn't found in the database.
   */
  public Record get(int id) throws IOException {
    try {
      // Header is not useful for this operation.
      raf.seek(Integer.BYTES);

      while (!eof()) {
        boolean valid = raf.readBoolean();
        int recordSize = raf.readInt();

        if (valid) {
          Record r = Record.deserialize(raf);

          if (r.getId() == id)
            return r;
        } else
          // Deleted records must not be read.
          raf.skipBytes(recordSize);
      }

    } catch (IOException e) {
      throw new IOException(
          "Error while retrieving record with id: " + id, e);
    }

    return null;
  }

  /*
   * Returns true if a new entity is successfully inserted
   * into the database and an exception otherwise.
   */
  public boolean insert(Record record) throws IOException {
    try {
      record.setId(getLastId() + 1);
      raf.seek(0);
      raf.writeInt(record.getId());

      // New records are always inserted at the end.
      raf.seek(raf.length());
      record.serialize(raf);

      return true;

    } catch (IOException e) {
      throw new IOException(
          "Unable to insert record record:\n" + record.toString(), e);
    }
  }

  /*
   * Returns true if it was successfully able to update
   * such record and false otherwise.
   */
  public boolean update(Record record) throws IOException {
    try {
      raf.seek(Integer.BYTES);

      while (!eof()) {
        long pos = raf.getFilePointer();
        boolean valid = raf.readBoolean();
        int recordSize = raf.readInt();

        if (valid) {
          Record r = Record.deserialize(raf);

          if (record.getId() == r.getId()) {
            byte[] recordAsBytes = record.toByteArray();
            raf.seek(pos);

            if (recordAsBytes.length <= recordSize)
              record.serialize(raf, recordSize);
            else {
              raf.writeBoolean(false);
              raf.seek(raf.length());

              record.serialize(raf);
            }

            return true;
          }

        } else
          raf.skipBytes(recordSize);
      }
    } catch (IOException e) {
      throw new IOException(
          "Error while updating record with id: " + record.getId(), e);
    }

    return false;
  }

  /*
   * Returns true if the record with such "id" is successfully
   * removed from the "database", false otherwise.
   */
  public boolean delete(int id) throws IOException {
    try {
      // Header is not useful for this operation.
      raf.seek(Integer.BYTES);

      while (!eof()) {
        // Position of the validation bit.
        long pos = raf.getFilePointer();
        boolean valid = raf.readBoolean();
        int recordSize = raf.readInt();

        if (valid) {
          Record r = Record.deserialize(raf);

          if (r.getId() == id) {
            raf.seek(pos);
            raf.writeBoolean(false);

            return true;
          }

        } else
          // Deleted records must not be read.
          raf.skipBytes(recordSize);
      }
    } catch (IOException e) {
      throw new IOException(
          "Error while deleting record with id: " + id, e);
    }

    return false;
  }

  private void preLoad(RandomAccessFile[] files) throws IOException {
    int step = 0;
    while(!eof()) {
      if(step == ways) {
        step = 0;
      }

      Record[] tempRecords = new Record[readRecords];

      for(int i = 0; i < tempRecords.length; i++) {
        tempRecords[i] = Record.deserialize(raf);
      }

      QuickSort.sort(tempRecords);

      for(int i = 0; i < tempRecords.length; i++) {
        tempRecords[i].serialize(files[step]);
      }

      step ++;
    }
  }

  private boolean allRead(RandomAccessFile[] files) throws IOException {
    boolean[] cases = new boolean[files.length];

    for(int i = 0; i < cases.length; i++) {
      cases[i] = (files[i].getFilePointer() == files[i].length());
    }

    boolean resp = cases[0];

    for(int i = 1; i < cases.length; i++) {
      resp = resp && cases[i];
    }

    return resp;
  }

  private boolean hasNext(RandomAccessFile file) throws IOException {
    return !(file.getFilePointer() == file.length());
  }

  private void intecalation(RandomAccessFile[] files, int pace, boolean phase) throws IOException{
    Record[] tempRecords = new Record[ways];
    int step;
    if(!phase) { // !phase trabalhar com o segundo par de arquivos
      step = ways;
    } else {
      step = 0;
    }
    for(int i = 0; i < ways; i++) {
      tempRecords[i] = Record.deserialize(files[step]);
    }

    while(!allRead(files)) {
      for(int i = 0; i < readRecords * ways; i++) {
        Record[] ordened = new Record[ways];

        for(int j = 0; j < ways; j++) {
          ordened[j] = tempRecords[j];
        }

        QuickSort.sort(ordened);

        ordened[0].serialize(files[step]);

        for(int j = 0; j < ways; j++) {
          if(ordened[0].getId() == tempRecords[j].getId()) {
            if(phase) {
              if(hasNext(files[j])) {
                if(tempRecords[j].getId() != 99999) {
                  tempRecords[j] = Record.deserialize(files[j]);
                }
              } else {
                tempRecords[j].setId(99999);
              }
            } else {
              if(hasNext(files[j])) {
                if(tempRecords[j].getId() != 99999) {
                  tempRecords[j] = Record.deserialize(files[j + ways]);
                }
              } else {
                tempRecords[j].setId(99999);
              }
            }
          }
        }
      }
    }
  }

  private RandomAccessFile biggestFile(RandomAccessFile[] files) throws IOException {
    int biggestLength = 0;
    RandomAccessFile biggest = new RandomAccessFile("temp", "rw");

    for(int i = 0; i < files.length; i++) {
      if(files[i].length() > biggestLength) {
        biggestLength = (int) files[i].length();
        biggest = files[i];
      }
    }

    return biggest;
  }

  public void sort() throws IOException {
    RandomAccessFile[] files = new RandomAccessFile[2 * ways];

    for(int i = 0; i < files.length; i++) {
      files[i] = new RandomAccessFile("tempArq" + (i + 1), "rw");
    }

    preLoad(files);

    boolean phase = false;

    for(int i = 0; i < (int)(Math.ceil(Math.log10(totalRecords / readRecords) / Math.log10(ways))); i++) {
      intecalation(files, (readRecords * (i + 1)), phase); // voltar array de arquivos e dps ve o completo ?
      if(!phase) {
        for(int j = 0; j < ways; j++) {
          //files[j].setLength(0);
          files[j].close();
          files[j] = new RandomAccessFile("tempArq" + (j + 1), "rw");
        }
      } else {
        for(int j = ways; j < (ways * 2) - 1; j++) {
          //files[i].setLength(0);
          files[j].close();
          files[j] = new RandomAccessFile("tempArq" + (j + 1), "rw");
        }
      }
      phase = !phase;
    }

    RandomAccessFile[] tempFiles = new RandomAccessFile[ways];

    if(!phase) { // se ao final da intercalação phase for true a resposta vai estar no 2 par ordenado

      for(int i = 0; i < ways; i++) {
        tempFiles[i] = files[i];
      }
      
      raf = biggestFile(tempFiles); // Não sei se ira funcionar

    } else {
      for(int i = 0; i < ways; i++) {
        tempFiles[i] = files[i + ways];
      }
      
      raf = biggestFile(tempFiles); // Não sei se ira funcionar
    }

  }
  
  /*
  public void sort() throws IOException {
    RandomAccessFile[] tempFiles = new RandomAccessFile[2 * this.ways];

    for(int i = 0; i < (2 * this.ways); i++) {
      tempFiles[i] = new RandomAccessFile("tempArq" + i, "rw");
    }
    try {
      raf.seek(Integer.BYTES);
      int step = 0;
      boolean way = true;
      RandomAccessFile writtenFile = tempFiles[0];

      while (!eof()) {
        Record[] records = new Record[this.readRecords];

        for (int i = 0; i < this.readRecords; i++)
          records[i] = Record.deserialize(raf);

        QuickSort.sort(records);
        
        for (Record record : records)
          record.serialize(writtenFile);

      }
    } catch (IOException e) {
      throw new IOException(
          "Error while sorting the database", e);
    }
  }
  */

  // Returns the file's first four bytes.
  private int getLastId() throws IOException {
    try {
      raf.seek(0);

      return raf.readInt();

    } catch (IOException e) {
      throw new IOException(
          "Unable to retrieve file header", e);
    }
  }

  /*
   * Returns whether there's still an offset between
   * the file pointer and the file's length.
   */
  private boolean eof() throws IOException {
    try {
      return raf.getFilePointer() == raf.length();

    } catch (IOException e) {
      throw new IOException(
          "Error while checking for EOF", e);
    }
  }
}
